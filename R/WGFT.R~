# This script provides a demonstration of how a weather generator can be designed:
# ESD is used to predict thanges in the pdfs for temperature and precipitation.
# Temperature: mean, stdv.
# Precipitation: mu, fw (assume similar spell statistics as in present time).
#
# This weather generator assumes that the past covariate structure between
# temperature and precipitation is constant and doesn't change in the future.
# Moreover, the method also assumes that the spell-statistics will stay the same.
# (more advanced method may perhaps predict changes to the spell-statistics).
#
# Rasmus Benestad

require(esd)

FTscramble <- function(x,interval=NULL,spell.stats=FALSE,wetfreq.pred=FALSE) {
  attributes(x) <- NULL
  n <- length(x)
  
  # This function scramles the phase information of the FT components of a
  # time series, maintaining the same spectral and time structure

  if (sum(is.na(x))>0) {
    ok <- is.finite(x)
    y <- approx((1:n)[ok],x[ok],xout=1:n,rule=2)$y
    x <- y
    rm('y')
  }
  
  # Fourier transform (FT) to obtain power and phase information
  X <- fft(x)
  #print(summary(Re(X))); print(summary(Im(X)))
  
  # Z contains the phase information
  Z <- Mod(X)
  #print(summary(Z))
  ReX <- Re(X)
  ImX <- Im(X)
  phiX <- Arg(X)
  #plot(phiX)
  
  # Set new phase information to random
  phiY <- runif(n,min=-pi,max=pi)
  ReY <- Z*cos(phiY)
  ImY <- Z*sin(phiY)
  ReY[1] <- ReX[1]; ImY[1] <- ImX[1]
#  ReY[n] <- ReX[n]; ImY[n] <- ImX[n]
  Y <- complex(real=ReY, imaginary=ImY)

  # Inverse FT to generate new time series:
  y <- fft(Y,inverse=TRUE)
  invisible(Re(y)/n)
}


WG.FT.t2m <- function(x=NULL,mean=NULL,sd=NULL,t=NULL,eofs=1:4,
                      select=NULL,lon=c(-20,20),lat=c(-20,20),
                      plot=TRUE,biascorrect=TRUE,verbose=FALSE) {
  # Single function for just temperature.
  # The arguments mean and sd are time series predicted through ESD
  # (zoo or station objects)
  if (is.null(x)) {
    data(ferder,envir=environment())
    x <- ferder
    rm('ferder')
  }
  
  if (is.null(mean)) {
    print('Estimate mean change')
    T2M <- retrieve('~/data/ERAINT/ERAINT_t2m_mon.nc',
                    lon=lon(x) + lon,lat=lat(x) + lat)
    ztm <- DSensemble.t2m(x,predictor=T2M,biascorrect=biascorrect,
                          plot=plot,lon=lon,lat=lat,eofs=eofs,
                          select=select,verbose=verbose)
    mean <- rowMeans(ztm,na.rm=TRUE) - mean(ztm,na.rm=TRUE)
  } else if (inherits(mean,'dsensemble'))
     mean <- rowMeans(mean,na.rm=TRUE) - mean(mean,na.rm=TRUE)
 
  if (is.null(sd)) {
    print('Estimate mean change')
    SLP <- retrieve('~/data/ERAINT/ERAINT_slp_mon.nc',
                    lon=lon(x) + lon,lat=lat(x) + lat)
    coredata(SLP) <- 100*coredata(SLP)  # The CMIP5 units are in Pa!
    if (plot) dev.new()
#    zts <- DSensemble.t2m(x,predictor=SLP,biascorrect=biascorrect,
#                          FUN='sd',plot=plot,lon=lon,lat=lat,eofs=eofs,
#                          path='data/CMIP5.mslp/',pattern='psl_Amon_ens',
#                          select=select,verbose=verbose)
    zts <- DSensemble.t2m(x,predictor=T2M,biascorrect=biascorrect,
                          FUN='sd',plot=plot,lon=lon,lat=lat,eofs=eofs,
                          FUNx='sd',       
                          select=select,verbose=verbose)
    sd <- rowMeans(zts,na.rm=TRUE) - mean(zts,na.rm=TRUE)
  } else if (inherits(sd,'dsensemble'))
    sd <- rowMeans(sd,na.rm=TRUE) - mean(sd,na.rm=TRUE)
 
  # Also allow for estimating the AR(1) coefficient of the Hurst coefficient
# Fractional Gaussian noise...?
  
  xa <- anomaly(x); clim <- x - xa
  y <- FTscramble(xa)
  if (plot) {dev.new(); plot(merge(zoo(xa),zoo(y)))}
  y <- y + clim

  # Time axis for projection:
  if (is.null(t)) {
    ly <- max(year(mean)); ny <- length(rownames(table(year(x)))) 
    interval <- c(ly-ny+1,ny)
    t <- index(x)
    t <- t - julian(t[1]) +
      julian(as.Date(paste(interval[1],month(x)[1],day(x)[1],sep='-')))
  }
  
  ym <- approx(julian(index(mean)),coredata(mean),xout=julian(t),rule=2)$y
  ys <- approx(julian(index(sd)),coredata(sd),xout=julian(t),rule=2)$y
  # Also use approx for the observations? Annual mean and sd?
  
  #qq-transform: temp(N1 -> N2) - year by year or for a given interval?
  z <- zoo(qnorm(pnorm(q=y,mean=mean(x,na.rm=TRUE),sd=sd(x,na.rm=TRUE)),
                 mean=ym,sd=ys),order.by=t)
  z <- attrcp(x,z)
  attr(z,'history') <- history.stamp(x)
  return(z)
}

WG.FT.precip <- function(x=NULL,mu=NULL,fw=NULL,ndd=NULL,t=NULL,
                         threshold=1,select=NULL,
                         lon=c(-10,10),lat=c(-10,10),
                         plot=TRUE,biascorrect=TRUE,
                         method='rgeom') {
  # Single function for just precipitation
  if (is.null(x)) {
    data(bjornholt,envir=environment())
    x <- bjornholt
    rm('bjornholt')
  }

  # Time axsis for projection:
  if (is.null(t)) {
    ly <- max(year(mean)); ny <- length(rownames(table(year(x)))) 
    interval <- c(ly-ny+1,ny)
    t <- index(x)
    t <- t - julian(t[1]) +
      julian(as.Date(paste(interval[1],month(x)[1],day(x)[1],sep='-')))
  }
  n <- length(t)

  # use fw to estimate the number of rainy days per year:
  x.fw <-  as.annual(x,'wetfreq',threshold=threshold)
    
  # Use predicted mu to generate exponentially distributed data:
  x.mu <- as.annual(x,'exceedance',threshold=threshold)

  # according to a geometric (default) or Poisson distribution
  x.nd <- subset(annual(spell(x,threshold=threshold)),is=1)
  
  if (is.null(mu)) {
    print('Estimate mean change')
    PRE <- retrieve('~/data/ERAINT/ERAINT_precip_mon.nc',
                    lon=lon(x) + lon,lat=lat(x) + lat)
    zmu <- DSensemble.precip(x,predictor=PRE,biascorrect=biascorrect,
                          plot=plot,lon=lon,lat=lat,eofs=eofs,
                          select=select,verbose=verbose,treshold=threshold)
    mu <- rowMeans(zmu,na.rm=TRUE) - mean(zmu,na.rm=TRUE)
  } else if (inherits(mu,'dsensemble'))
    mu <- rowMeans(mu,na.rm=TRUE) - mean(mu,na.rm=TRUE)
  
  if (is.na(fw)) {
    SLP <- retrieve('~/data/ERAINT/ERAINT_slp_mon.nc',
                    lon=lon(x) + lon,lat=lat(x) + lat)
    coredata(SLP) <- 100*coredata(SLP)  # The CMIP5 units are in Pa!
    if (plot) dev.new()
    zfw <- DSensemble.precip(x,predictor=SLP,biascorrect=biascorrect,
                             FUN='wetfreq',threshold=threshold,
                             plot=plot,lon=lon,lat=lat,eofs=eofs,
                             path='data/CMIP5.mslp/',pattern='psl_Amon_ens',
                             select=select,verbose=verbose)
    fw <- rowMeans(zfw,na.rm=TRUE) - mean(zfw,na.rm=TRUE)
  } else if is.null(fw)
    fw <- rnorm(n,mean=mean(coredata(x.fw)),sd=sd(coredata(x.fw))) else
  if (inhewrits(fw,'dsensemble'))
    fw <- rowMeans(fw,na.rm=TRUE) - mean(fw,na.rm=TRUE)
  
  if (is.na(ndd)) {
    SLP <- retrieve('~/data/ERAINT/ERAINT_slp_mon.nc',
                    lon=lon(x) + lon,lat=lat(x) + lat)
    coredata(SLP) <- 100*coredata(SLP)  # The CMIP5 units are in Pa!
    if (plot) dev.new()
    znd <- DSensemble.precip(x,predictor=SLP,biascorrect=biascorrect,
                             FUN='spell',threshold=threshold,
                             plot=plot,lon=lon,lat=lat,eofs=eofs,
                             path='data/CMIP5.mslp/',pattern='psl_Amon_ens',
                             select=select,verbose=verbose)
    ndd <- rowMeans(znd,na.rm=TRUE) - mean(znd,na.rm=TRUE)
  } else if is.null(ndd)
    ndd <- rnorm(ny,mean=mean(coredata(x.nd)),sd=sd(coredata(x.nd))) else
  if (inherits(ndd,'dsensemble'))
    ndd <- rowMeans(nnd,na.rm=TRUE) - mean(nnd,na.rm=TRUE)
  
  # One alternative: qq-transform: precip(exp1 -> exp2)
#  pr.x.wet <- qexp(pexp(q=round(365.25*coredata(x.fw)),
#                        rate=1/coredata(x.mu),na.rm=TRUE)),
#                   rate=1/coredata(mu))

  nwet <- round( (julian(as.Date(paste(year(t),'12-31',sep='-'))) -
           julian(as.Date(paste(year(t),'01-01',sep='-')))) *
             coredata(fw) )

  z <- coredata(x)
  for ( i in 1:ny ) {
    y <- rexp(nwet[i],1/coredata(mu)[i])
    lambda <- coredata(x.nd[,1])
    eval(parse(text=paste('ndd <- ',method,'(366,1/lambda)',sep='')))
    # Estimate number of dry days:
    nd <- round( (1-coredata(fs[i])*nwet[i] ) )
    # Estimate the number of random dry spells:
    md <- sum( cumsum(ndd) <= nd )
    # estimate the number of wet spells:
    mw <- (nwet[i] - nd)/(md-1)
    dry <- ndd[1:md]
    # distribute the dry days in y: let the rain events start randomly
    wetstart <- runif(mw,min=1,max=nwet[i]-lambda)
    y[wetstart:(wetstart+dry-1)] <- 0
    z[year(t)==year(t)[i]] <- y
  }
  z <- zoo(z,order.by=t)
  z <- attrcp(x,z)
  attr(z,'history') <- history.stamp(x)
  return(z)
}

WG.FTscramble.t2mpr <- function(t2m=NULL,pr=NULL,threshold=1,select=NULL) {
  if (is.null(t2m)) {
    data(ferder,envir=environment())
    t2m <- ferder
    rm('ferder')
  }
  if (is.null(precip)) {
    data(bjornholt,envir=environment())
    pr <- bjornholt
    rm('bjornholt')
  }

  lon <- lon(t2m) + c(-10,10)
  lat <- lat(t2m) + c(-10,10)
  
  SLP <- retrieve('~/data/ERAINT/ERAINT_slp_mon.nc',lon=lon,lat=lat)
  coredata(SLP) <- 100*coredata(SLP)  # The CMIP5 units are in Pa!
  T2M <- retrieve('~/data/ERAINT/ERAINT_t2m_mon.nc',lon=lon,lat=lat)
  PRE <- retrieve('~/data/ERAINT/ERAINT_pr_mon.nc',lon=lon,lat=lat)

  ztm = DSensemble.t2m(t2m,predictor=T2M,biascorrect=TRUE,plot=FALSE,
                       lon=c(-10,10),lat=c(-10,10),select=select)
  zts = DSensemble.t2m(t2m,FUN='sd',predictor=SLP,biascorrect=TRUE,plot=FALSE,
                       path='data/CMIP5.mslp/',pattern='psl_Amon_ens',
                       lon=c(-10,10),lat=c(-10,10),select=select)
  
  zpm = DSensemble.precip(pr,FUN='wetmean',predictor=PRE,biascorrect=TRUE,
    plot=FALSE,select=select)
  if (wetfreq.pred)
    zpf = DSensemble.precip(pr,FUN='wetfreq',predictor=SLP,biascorrect=TRUE,plot=FALSE,
                            path='data/CMIP5.mslp/',pattern='psl_Amon_ens',select=select)

# select an equal number of years at the end of the downscaled results if none is specified
  if (is.null(interval)) {
    interval <- c(max(year(ztm))-ny+1,max(year(ztm)))
  }
  ztm  <- subset(ztm,it=interval)
  zts  <- subset(zts,it=interval)
  zpm  <- subset(zpm,it=interval)
  
# Generate the daily variability from the observations:
  t2ma <- anomaly(t2m); t2mc <- t2m - t2ma
  xy <- merge(zoo(t2m),zoo(pr),zoo(t2mc),all=FALSE)
  years <- as.numeric(rownames(table(year(xy))))
  ny <- length(years)

  wet <- (xy[,2] > threshold) & (is.finite(xy[,1])) & (is.finite(xy[,2]))
  dry <- (xy[,2] <= threshold) & (is.finite(xy[,1])) & (is.finite(xy[,2]))
  if (spell.stats) L <- spell(pr,threshold=threshold)

  # Rainy days:
  # Find the co-variate structures in daily temperature and precipitation
  X <- coredata(xy[wet,1:2])
  X[,2] <- log(X[,2])
  qqnorm(X[,2])
  pca <- svd(X)
  # scramble the principal components:
  z1 <- FTscramble(pca$u[,1])
  z2 <- FTscramble(pca$u[,2])
  pca$u <- cbind(z1,z2)
  X <- pca$u %*% diag(pca$d) %*% t(pca$v)
  X[,2] <- exp(X[,2])

  # All days: set up date string
  t <- julian(as.Date(paste(year(xy)-year(xy)[1]+interval[1],
                            month(xy),day(xy),sep='-')))
  x <- zoo(coredata(xy[,1]),order.by=t)
  attributes(x) <- NULL

  # initialise temperature and precip - for t2m, add observed daily climatology
  n <- length(x)
  pr.x <- rep(0,n) 

  # shoehorn the rainy day temperature and precipitation into series
  t2m.x[wet] <-  X[,1]

  # generate time series for predicted mean and sd with same length as the scrambled
  # daily series: use the seasonal estimates
  tensm <- rowMeans(ztm,na.rm=TRUE) - mean(ztm,na.rm=TRUE)
  tenss <- rowMeans(zts,na.rm=TRUE) - mean(zts,na.rm=TRUE)
  penss <- rowMeans(zpm,na.rm=TRUE) - mean(zpm,na.rm=TRUE)

  ytm <- approx(julian(index(ztm)),tensm,xout=julian(t),rule=2)$y
  yts <- approx(julian(index(zts)),tensm,xout=julian(t),rule=2)$y
  ypm <- approx(julian(index(ztm)),pensm,xout=julian(t),rule=2)$y
  
  #qq-transform: temp(N1 -> N2) - year by year or for a given interval?
  t2m.x <- qnorm(pnorm(q=t2m.x,mean=mean(t2m.x,na.rm=TRUE),sd=sd(t2m.x,na.rm=TRUE)),
                 mean=ytm,sd=yts)
  
  #qq-transform: precip(exp1 -> exp2)
  pr.x.wet <- qexp(pexp(q=X[,2],rate=1/mean(xy[,2],na.rm=TRUE)),
                   rate=1/ypm)
  
  #empirical adjustment to precipitation?
  
  # shoehorn the rainy day temperature and precipitation into series
  pr.x[wet] <- pr.x.wet 
  t2m.x <- zoo(t2m.x,order.by=t)
  t2m.x <- attrcp(t2m)
  attr(t2m.x,'method') <- 'DShydro'
  attr(t2m.x,'type') <- 'result: ESD + WG'
  attr(t2m.x,'activity') <- 'CMIP5'
  attr(t2m.x,'experiment') <- 'RCP 4.5'
  pr.x <- zoo(pr.x,order.by=t)
  pr.x <- attrcp(pr)
  attr(pr.x,'method') <- 'DShydro'
  attr(pr.x,'type') <- 'result: ESD + WG'
  attr(pr.x,'activity') <- 'CMIP5'
  attr(pr.x,'experiment') <- 'RCP 4.5'
  
  y <- list(t2m=t2m.x,pr=pr.x)
  attr(y,'history') <- history.stamp(t2m)
  class(y) <- class(t2m)
  return(y)
}

# Pca temp plus precip. Phase scramble pc. DS mu fw mean temp sd.
# Qq-map to new pdf: exp plus ~N()
# Rainy dais only. Temp + dry seperately. Order stats for blending

